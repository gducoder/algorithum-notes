---
title: "字符串匹配基础（上）"
date: 2019-02-21T22:20:32+08:00
draft: false
tags:
   - JAVA
categories:
  - 技术
  - 归档
---


# 字符串搜索算法

以下主要为课程笔记。

## BF算法(brute force)



两个术语：主串、模式串

比方说，我们在字符串A中查找B，那A就是主串，B就是模式串。我们把主串的长度记作N，模式串的长度记为M。因为在主串中查找模式串，所以N>M。

作为最简单，最暴力的字符串匹配算法，BF算法的思想，可以用一句话来概括，那就是：我们在主串中，检查其实位置分别是0,1,2, ... , n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配的。

![2019-02-26-001](https://gitee.com/gdhu/prvpic/raw/master/2019-02-26-001.png)

算法实现：


第一种方法 i 指向匹配子串的起始位置。

```java
  public static int search(String txt, String pat) {
    int N = txt.length();
    int M = pat.length();
    for (int i = 0; i <= N - M; i++) {
      int j;
      for (j = 0; j < M; j++) {
        if (txt.charAt(i + j) != pat.charAt(j))
          break;
      }
      if (j == M)
        return i;
    }
    return N;
  }
```

第二种方法 i 指向匹配子串的末尾。

```java
  public static int search2(String txt, String pat) {
    int N = txt.length();
    int M = pat.length();
    // i points to end of substring
    int i, j;
    for (i = 0, j = 0; i < N && j < M; i++) {
      if (txt.charAt(i) == pat.charAt(j)) {
        j++; // match
      } else {
        i -= j; // miss match
        j = 0;
      }
    }

    if (j == M)
      return i - M; // found
    else
      return N; // not found
  }

```

尽管理论上最坏时间复杂度为O(n*m)，但在实际开发中，它却是一个很常用的字符串匹配算法。

为什么呢？

1、在实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当途中遇到不能匹配的字符的时候，就可以停止了，不需要把M个字符都对比一下。所以，尽管理论上最坏时间复杂度为O(N*M)，但是，统计意义上，大部分情况下，算法的平均时间复杂度为O(N)。

2、朴素字符串匹配算法思想简单，代码的实现也非常简单。简单意味着不容易出错，如果有bug也容易暴露和修复。在工程中，在性能要求满足的前提下，简单是首选。这也是我们常说的，[KISS原则](https://en.wikipedia.org/wiki/KISS_principle)。

所以，在实际软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。

## RK算法

本质上和BF算法一样。但可以通过哈希函数计算模式串和主串中子串的哈希值。哈希值的计算和比较很高效。

具体的，每个子串的哈希值计算为常数时间。利用了子串间的哈希函数交集。

通过哈希函数的设计，可以避免碰撞。

使用除留余数法，选择一个大的质数，例如10的20次方大的。碰撞的概率为10^-20。是一个很低的概率。

算法时间复杂度为O(N)。




![2019-02-26-002](https://gitee.com/gdhu/prvpic/raw/master/2019-02-26-002.png)

![2019-02-26-003](https://gitee.com/gdhu/prvpic/raw/master/2019-02-26-003.png)

## BM算法

下面介绍BM（Boyer-Moore）算法。

核心思想，我们把模式串和主串匹配的过程，看作模式串在主串中不停的往后滑动。当遇到不匹配的字符时，BF和RK算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。

![2019-02-27-001](https://gitee.com/gdhu/prvpic/raw/master/2019-02-27-001.png)

在这个例子中，主串中的c在模式串中是不存在的，所以我们可以一次性把模式串多往后滑动几位，把模式串移动到c的后面。

![2019-02-27-002](https://gitee.com/gdhu/prvpic/raw/master/2019-02-27-002.png)

### BM算法原理分析

1、坏字符规则

BM算法的匹配顺序比较特别，它是按照模式串下标从大到小的顺序，倒着匹配的。

![2019-02-27-003](https://gitee.com/gdhu/prvpic/raw/master/2019-02-27-003.png)

我们从模式串的末尾往前倒着匹配，当我们发现摸个字符没法匹配的时候。我们把这个没有匹配的字符串叫做**坏字符**（主串中的字符）。

1.1 主串中的坏字符在模式串中**没有出现过**

例子中移动3位

![2019-02-27-006](https://gitee.com/gdhu/prvpic/raw/master/2019-02-27-006.png)

1.2 主串中的坏字符在模式串中**出现过**

例子中移动2位

![2019-02-27-005](https://gitee.com/gdhu/prvpic/raw/master/2019-02-27-005.png)

当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记为si，如果坏字符在模式串中存在，坏字符在模式串中的下标记作xi(>=0)，如果不存在记为xi=-1。那么模式串往后移动的位数就等于si-xi。（注意，这里说的下标，都是字符串在模式串中的下标）

这里要说明的是，如果坏字符在模式串中多次出现，我们在计算xi的时候，选择最靠右的那一个，因为这样不会让模式串滑动太多，导致本来可能匹配的情况被滑动略过。

注意：移动的位数可能是负数，这里将这种情况，模式串向后滑动1位，和bf算法一样。

利用坏字符原则，BM在最好情况下的时间复杂度非常低，是O(N/M)。比如，主串为aaabaaabaaabaaab，模式串为aaaa。每次比对，模式串都可以直接移动四位。所以匹配有类似特点的模式串和主串的时候，BM算法非常高效。

但，仅仅利用坏字符规则，BM算法在主串为aaaaaaaaaa，模式串为baaaa的时候，模式串每次只能移动1位。算法最差时间复杂度为O(NM)。

算法4中说，通常情况下BM算法是够用的。


2、好后缀规则（这部分有点烧脑，需要在研究研究）

对BM算法的进一步改进。
